# Linux系统IO原理

## VFS
VFS Virtual File System 虚拟文件系统
程序的维度上包涵kernel内核，就是一个程序，然后就是用户空间的程序：app。每个程序是逻辑的线性的地址，通过MMU转换到物理地址。一个程序模拟的是
使用整个的内存，其中他觉得他自己是独占内核的，他的地址空间里面包含了内核的引用。app不能直接访问硬件，读IO（磁盘和网卡）的时候，要先通过内核的
系统调用（除了直接IO）。程序要获取数据的时候，这里有几个抽象：  
1、内核：既管着内存的分配，又管着磁盘IO。这里有个VFS，虚拟文件系统，他就是内存里的一棵目录树，树上的不同的节点可以映射到不同的物理位置。每个
   物理位置可以是具体的文件系统，比如FAT、ext3、ext4护着网络节点、虚拟的块设备等。Linux跟Window不同，后者的C盘就是C盘，D盘就是D盘。
   而Linux的VFS是虚拟的，为的是在各种文件系统和app之间上面加一个屏蔽，屏蔽和解耦掉各个异构的文件系统，因为各个硬件驱动都不一样。类似JDBC在
   程序跟数据库之间起的作用一样。
2、inode。 inode号就把它想成是一个ID。在VFS之中，每一个文件被打开的时候都有一个inode号，来唯一地代表他。程序向读数据的时候，先访问内核，说
   在VFS树中打开那个文件，然后inode号被加载，然后元数据被加载，并且先由内核读到pagecache（页缓存）内存中，默认4k大小。如果有多个程序都来
   读同一个IO，则并不会开辟多个pagecache内存，而是一份pagecache给他们共享。pagecache是内存里的对数据的一个缓存。如果由app把某个pagecache
   里的数据给改了，这个修改会比较快，而这个改过了的pagecache则被标记为"dirty"。程序和硬件之间隔了一个内核，内核通过pagecache来维护想要读取
   的数据，如果对其中数据修改的话，他会被标记为"脏"。为脏的pagecache就有一个flush的过程，书写到磁盘中去，那到底是什么时候写的呢？这就是区别
   各种IO模型的依据。可以在程序没写的时候立刻刷入磁盘，但是性能很低，也可以交由系统内核来决定什么时候来写脏页。这个脏的标识是内核对于所有上层
   打开的文件的统一的管理，他并不是针对某一个文件的，内核会在一个周期或者阈值达到后整体地把脏页们写到磁盘中去。所以一种是程序调用内核直接刷，
   一个是程序等着内核刷。直接刷丢的少，调用内核丢的多。假设有一个30G的内存，搞不好5s之内来了个2.8G的数据，这时候如果突然断电了，则这2.8G
   数据就丢了。断电的时候既没有出发到脏的阈值，也没触发到时间点的阈值。
3、文件描述符 FD。FD是交割程序们用的，虽然这个文件叫inode。FD里面有指针和seek，是一个偏移量，不同的程序偏移量不一样。每个程序在读取文件不同
   位置的时候有各自不同的指针。20：51


这里有一个

把文件
读到pagecache中，内核在一个app看来

VFS树、inode、pagecache在内存里， 4k、dirty、flush  