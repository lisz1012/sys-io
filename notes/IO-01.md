# Linux系统IO原理

## VFS
VFS Virtual File System 虚拟文件系统
程序的维度上包涵kernel内核，就是一个程序，然后就是用户空间的程序：app。每个程序是逻辑的线性的地址，通过MMU转换到物理地址。一个程序模拟的是
使用整个的内存，其中他觉得他自己是独占内核的，他的地址空间里面包含了内核的引用。app不能直接访问硬件，读IO（磁盘和网卡）的时候，要先通过内核的
系统调用（除了直接IO）。程序要获取数据的时候，这里有几个抽象：  
1、内核：既管着内存的分配，又管着磁盘IO。这里有个VFS，虚拟文件系统，他就是内存里的一棵目录树，树上的不同的节点可以映射到不同的物理位置。每个
   物理位置可以是具体的文件系统，比如FAT、ext3、ext4或者网络节点、虚拟的块设备等。Linux跟Window不同，后者的C盘就是C盘，D盘就是D盘。
   而Linux的VFS是虚拟的，为的是在各种文件系统和app之间上面加一个屏蔽，屏蔽和解耦掉各个异构的文件系统，因为各个硬件驱动都不一样。类似JDBC在
   程序跟数据库之间起的作用一样。虚拟文件系统里面有以下这么几个东西：
2、inode。 inode号就把它想成是一个ID。在VFS之中，每一个文件被打开的时候都有一个inode号，来唯一地代表他。程序向读数据的时候，先访问内核，说
   在VFS树中打开那个文件，然后inode号被加载，然后元数据被加载，并且先由内核读到pagecache（页缓存）内存中，默认4k大小。如果有多个程序都来
   读同一个IO，也就是打开的是同一个文件，则并不会开辟多个pagecache内存，而是一份pagecache给他们共享。pagecache是内存里的对数据的一个缓存。
   如果由app把某个pagecache
   里的数据给改了，这个修改会比较快，而这个改过了的pagecache则被标记为"dirty"。程序和硬件之间隔了一个内核，内核通过pagecache来维护想要读取
   的数据，如果对其中数据修改的话，他会被标记为"脏"。为脏的pagecache就有一个flush的过程，书写到磁盘中去，那到底是什么时候写的呢？这就是区别
   各种IO模型的依据。可以在程序每次写的时候立刻刷入磁盘，例如java中调用flush()，但是性能很低，也可以交由系统内核来决定什么时候来写脏页。
   这个脏的标识是内核对于所有上层
   打开的文件的统一的管理，他并不是针对某一个文件的，内核会在一个周期或者阈值达到后整体地把脏页们写到磁盘中去。所以一种是程序调用内核直接刷，
   一个是程序等着内核刷。直接刷丢的少，调用内核丢的多。假设有一个30G的内存，搞不好5s之内来了个2.8G的数据，这时候如果突然断电了，则这2.8G
   数据就丢了。断电的时候既没有触发到脏的阈值，也没触发到时间点的阈值。
3、文件描述符 FD。FD是交给程序们用的，虽然这个文件叫inode。FD里面有指针和seek，是一个偏移量，不同的程序偏移量不一样。每个程序在读取文件不同
   位置的时候有各自不同的指针, 找到自己该读写的这个pagecache，如果修改的不一样位置的数据的时候，也不用抢锁，修改到同一位置要抢锁，并行串行化。
   
## 实操验证
```
[root@localhost /]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda3        18G  4.2G   14G  24% /
devtmpfs        560M     0  560M   0% /dev
tmpfs           575M     0  575M   0% /dev/shm
tmpfs           575M  8.1M  567M   2% /run
tmpfs           575M     0  575M   0% /sys/fs/cgroup
/dev/sda1       297M  152M  146M  51% /boot
tmpfs           115M     0  115M   0% /run/user/0
[root@localhost /]# ll
total 28
lrwxrwxrwx.   1 root root    7 Mar 20  2020 bin -> usr/bin
dr-xr-xr-x.   4 root root 4096 Mar 20  2020 boot
drwxr-xr-x.  19 root root 3260 Nov  4 15:35 dev
drwxr-xr-x. 138 root root 8192 Nov  4 15:35 etc
drwxr-xr-x.   3 root root   22 Mar 20  2020 home
lrwxrwxrwx.   1 root root    7 Mar 20  2020 lib -> usr/lib
lrwxrwxrwx.   1 root root    9 Mar 20  2020 lib64 -> usr/lib64
drwxr-xr-x.   2 root root    6 Nov  5  2016 media
drwxr-xr-x.   2 root root    6 Nov  5  2016 mnt
drwxr-xr-x.   3 root root   16 Mar 20  2020 opt
dr-xr-xr-x. 125 root root    0 Nov  4 15:35 proc
dr-xr-x---.  16 root root 4096 Mar 21  2020 root
drwxr-xr-x.  34 root root 1060 Nov  4 15:35 run
lrwxrwxrwx.   1 root root    8 Mar 20  2020 sbin -> usr/sbin
drwxr-xr-x.   2 root root    6 Nov  5  2016 srv
dr-xr-xr-x.  13 root root    0 Nov  4 15:35 sys
drwxrwxrwt.  23 root root 4096 Nov  4 15:36 tmp
drwxr-xr-x.  13 root root  155 Mar 20  2020 usr
drwxr-xr-x.  21 root root 4096 Nov  4 15:35 var
```
其中`/boot`虽然看上去像是跟其他目录是在一起的，他其实的物理位置是`/dev/sda1`。根目录下其他的东西都在`/dev/sda3 `
`/boot`的加载比较复杂：Linux最开始启动的时候，BIOS读引导程序grub，引导完成之后先加载`kernel.img`内核镜像到内存，然后后者就在内存中展开了，
他比较"叛逆"，就把`/boot`干掉了，然后加载 / 和/dev, /boot, /etc等，而加载完了之后，他又把/boot加载回来，用 `/dev/sda1`覆盖了`/dev/sda3`
查看一下`/boot`发现里面有引导程序和一些内核的镜像：
```
[root@localhost /]# cd /boot
[root@localhost boot]# ll
total 130728
-rw-r--r--. 1 root root   137696 Nov 22  2016 config-3.10.0-514.el7.x86_64
drwxr-xr-x. 2 root root       27 Mar 20  2020 grub
drwx------. 6 root root      111 Mar 20  2020 grub2
-rw-------. 1 root root 64522489 Mar 20  2020 initramfs-0-rescue-6bb17e5f0969495d9c0d16577729c48a.img
-rw-------. 1 root root 28313008 Mar 20  2020 initramfs-3.10.0-514.el7.x86_64.img
-rw-------. 1 root root 16489747 Mar 20  2020 initramfs-3.10.0-514.el7.x86_64kdump.img
-rw-r--r--. 1 root root 10209710 Mar 20  2020 initrd-plymouth.img
-rw-r--r--. 1 root root   277953 Nov 22  2016 symvers-3.10.0-514.el7.x86_64.gz
-rw-------. 1 root root  3113253 Nov 22  2016 System.map-3.10.0-514.el7.x86_64
-rwxr-xr-x. 1 root root  5392080 Mar 20  2020 vmlinuz-0-rescue-6bb17e5f0969495d9c0d16577729c48a
-rwxr-xr-x. 1 root root  5392080 Nov 22  2016 vmlinuz-3.10.0-514.el7.x86_64
```
umount之后根目录下的boot目录就空了：
```
[root@localhost /]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda3        18G  4.2G   14G  24% /
devtmpfs        560M     0  560M   0% /dev
tmpfs           575M     0  575M   0% /dev/shm
tmpfs           575M  8.2M  567M   2% /run
tmpfs           575M     0  575M   0% /sys/fs/cgroup
tmpfs           115M     0  115M   0% /run/user/0
[root@localhost /]# ll
total 20
lrwxrwxrwx.   1 root root    7 Mar 20  2020 bin -> usr/bin
drwxr-xr-x.   2 root root    6 Mar 20  2020 boot
drwxr-xr-x.  19 root root 3260 Nov  4 15:35 dev
drwxr-xr-x. 138 root root 8192 Nov  4 15:35 etc
drwxr-xr-x.   3 root root   22 Mar 20  2020 home
lrwxrwxrwx.   1 root root    7 Mar 20  2020 lib -> usr/lib
lrwxrwxrwx.   1 root root    9 Mar 20  2020 lib64 -> usr/lib64
drwxr-xr-x.   2 root root    6 Nov  5  2016 media
drwxr-xr-x.   2 root root    6 Nov  5  2016 mnt
drwxr-xr-x.   3 root root   16 Mar 20  2020 opt
dr-xr-xr-x. 119 root root    0 Nov  4 15:35 proc
dr-xr-x---.  16 root root 4096 Mar 21  2020 root
drwxr-xr-x.  34 root root 1060 Nov  4 15:35 run
lrwxrwxrwx.   1 root root    8 Mar 20  2020 sbin -> usr/sbin
drwxr-xr-x.   2 root root    6 Nov  5  2016 srv
dr-xr-xr-x.  13 root root    0 Nov  4 15:35 sys
drwxrwxrwt.   9 root root  249 Nov  4 15:36 tmp
drwxr-xr-x.  13 root root  155 Mar 20  2020 usr
drwxr-xr-x.  21 root root 4096 Nov  4 15:35 var
[root@localhost /]# cd boot
[root@localhost boot]# ll
total 0
```
再次mount就又回来了：
```
[root@localhost boot]# mount /dev/sda1 /boot
[root@localhost boot]# ll
total 0
[root@localhost boot]# cd /boot
[root@localhost boot]# ll
total 130728
-rw-r--r--. 1 root root   137696 Nov 22  2016 config-3.10.0-514.el7.x86_64
drwxr-xr-x. 2 root root       27 Mar 20  2020 grub
drwx------. 6 root root      111 Mar 20  2020 grub2
-rw-------. 1 root root 64522489 Mar 20  2020 initramfs-0-rescue-6bb17e5f0969495d9c0d16577729c48a.img
-rw-------. 1 root root 28313008 Mar 20  2020 initramfs-3.10.0-514.el7.x86_64.img
-rw-------. 1 root root 16489747 Mar 20  2020 initramfs-3.10.0-514.el7.x86_64kdump.img
-rw-r--r--. 1 root root 10209710 Mar 20  2020 initrd-plymouth.img
-rw-r--r--. 1 root root   277953 Nov 22  2016 symvers-3.10.0-514.el7.x86_64.gz
-rw-------. 1 root root  3113253 Nov 22  2016 System.map-3.10.0-514.el7.x86_64
-rwxr-xr-x. 1 root root  5392080 Mar 20  2020 vmlinuz-0-rescue-6bb17e5f0969495d9c0d16577729c48a
-rwxr-xr-x. 1 root root  5392080 Nov 22  2016 vmlinuz-3.10.0-514.el7.x86_64
[root@localhost boot]# ll
total 130728
-rw-r--r--. 1 root root   137696 Nov 22  2016 config-3.10.0-514.el7.x86_64
drwxr-xr-x. 2 root root       27 Mar 20  2020 grub
drwx------. 6 root root      111 Mar 20  2020 grub2
-rw-------. 1 root root 64522489 Mar 20  2020 initramfs-0-rescue-6bb17e5f0969495d9c0d16577729c48a.img
-rw-------. 1 root root 28313008 Mar 20  2020 initramfs-3.10.0-514.el7.x86_64.img
-rw-------. 1 root root 16489747 Mar 20  2020 initramfs-3.10.0-514.el7.x86_64kdump.img
-rw-r--r--. 1 root root 10209710 Mar 20  2020 initrd-plymouth.img
-rw-r--r--. 1 root root   277953 Nov 22  2016 symvers-3.10.0-514.el7.x86_64.gz
-rw-------. 1 root root  3113253 Nov 22  2016 System.map-3.10.0-514.el7.x86_64
-rwxr-xr-x. 1 root root  5392080 Mar 20  2020 vmlinuz-0-rescue-6bb17e5f0969495d9c0d16577729c48a
-rwxr-xr-x. 1 root root  5392080 Nov 22  2016 vmlinuz-3.10.0-514.el7.x86_64
```
目录树结构趋向于稳定，但有个映射的过程。一个目录中东西太多的话，可以把这些内容拷贝到一个单独的硬盘上，然后把硬盘挂载到这个目录，这样就扩容了。

## 文件类型
冯 诺伊曼曰：计算机的组成有计算器、控制器、主存储器、输入输出设备。类Unix系统做了一个抽象：一切皆文件。基于文件就可以应用到IO流。在Linux中文件的类型其实有
很多很多。我们说几个常用的：用"-"打头的就是普通文件，可以是可执行文件、图片、文本等， 用"d"打头的是目录的意思。"b"打头的是块设备：可以来回
漂移地读，而不受约束，就是块设备；否则就是"c"打头的字符设备，读不到过去和将来的数据，可能还需要编解码。键盘、网卡创建的文件都是字符设备；硬盘
是块设备。"s"开头的事socket。"p"开头的是pipeline，管道。[eventpoll]: epoll提供的内存区域。"l"开头的是链接。c、b开头的主要在/dev下。  

### 硬链接
```
[root@localhost ~]# vim lisz.txt
[root@localhost ~]# ln /root/lisz.txt /root/ooxx.txt
[root@localhost ~]# ll
total 20
-rw-------. 1 root root 2770 Mar 20  2020 anaconda-ks.cfg
drwxr-xr-x. 2 root root    6 Mar 20  2020 Desktop
drwxr-xr-x. 2 root root    6 Mar 20  2020 Documents
drwxr-xr-x. 2 root root    6 Mar 20  2020 Downloads
-rw-r--r--. 1 root root 2778 Mar 20  2020 initial-setup-ks.cfg
-rw-r--r--. 2 root root   13 Nov  4 17:06 lisz.txt
drwxr-xr-x. 2 root root    6 Mar 20  2020 Music
-rw-r--r--. 2 root root   13 Nov  4 17:06 ooxx.txt
-rw-------. 1 root root 2061 Mar 20  2020 original-ks.cfg
drwxr-xr-x. 2 root root    6 Mar 20  2020 Pictures
drwxr-xr-x. 2 root root    6 Mar 20  2020 Public
drwxr-xr-x. 2 root root    6 Mar 20  2020 Templates
drwxr-xr-x. 2 root root    6 Mar 20  2020 Videos
[root@localhost ~]# stat lisz.txt
  File: ‘lisz.txt’
  Size: 13        	Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d	Inode: 34794314    Links: 2
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2020-11-04 17:06:41.734891259 -0800
Modify: 2020-11-04 17:06:41.734891259 -0800
Change: 2020-11-04 17:07:01.217265200 -0800
 Birth: -
[root@localhost ~]# stat ooxx.txt 
  File: ‘ooxx.txt’
  Size: 13        	Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d	Inode: 34794314    Links: 2
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2020-11-04 17:06:41.734891259 -0800
Modify: 2020-11-04 17:06:41.734891259 -0800
Change: 2020-11-04 17:07:01.217265200 -0800
 Birth: -
[root@localhost ~]#
```
两个是同一个文件，他们的inode号是一样的，只不过在虚拟目录中映射到不同的路径下。两个变量名：lisz.txt和ooxx.txt他们指向了同一个物理位置。
修改任意一个，另一个也会有变化. 可以看到这两个文件的计数都是2。删掉其中一个，则只是少了一个引用，原来的文件还在, 但是引用计数降为1：
```
[root@localhost ~]# rm -f ./lisz.txt 
[root@localhost ~]# ll
total 16
-rw-------. 1 root root 2770 Mar 20  2020 anaconda-ks.cfg
drwxr-xr-x. 2 root root    6 Mar 20  2020 Desktop
drwxr-xr-x. 2 root root    6 Mar 20  2020 Documents
drwxr-xr-x. 2 root root    6 Mar 20  2020 Downloads
-rw-r--r--. 1 root root 2778 Mar 20  2020 initial-setup-ks.cfg
drwxr-xr-x. 2 root root    6 Mar 20  2020 Music
-rw-r--r--. 1 root root   17 Nov  4 17:13 ooxx.txt
-rw-------. 1 root root 2061 Mar 20  2020 original-ks.cfg
drwxr-xr-x. 2 root root    6 Mar 20  2020 Pictures
drwxr-xr-x. 2 root root    6 Mar 20  2020 Public
drwxr-xr-x. 2 root root    6 Mar 20  2020 Templates
drwxr-xr-x. 2 root root    6 Mar 20  2020 Videos
```
### 软链接（符号链接）
```
[root@localhost ~]# ln -s /root/ooxx.txt /root/lisz.txt
[root@localhost ~]# ll
total 16
-rw-------. 1 root root 2770 Mar 20  2020 anaconda-ks.cfg
drwxr-xr-x. 2 root root    6 Mar 20  2020 Desktop
drwxr-xr-x. 2 root root    6 Mar 20  2020 Documents
drwxr-xr-x. 2 root root    6 Mar 20  2020 Downloads
-rw-r--r--. 1 root root 2778 Mar 20  2020 initial-setup-ks.cfg
lrwxrwxrwx. 1 root root   14 Nov  4 17:22 lisz.txt -> /root/ooxx.txt

[root@localhost ~]# stat lisz.txt 
  File: ‘lisz.txt’ -> ‘/root/ooxx.txt’
  Size: 14        	Blocks: 0          IO Block: 4096   symbolic link
Device: 803h/2051d	Inode: 33574981    Links: 1
Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2020-11-04 17:22:24.275698012 -0800
Modify: 2020-11-04 17:22:22.471663210 -0800
Change: 2020-11-04 17:22:22.471663210 -0800
 Birth: -
[root@localhost ~]# stat ooxx.txt 
  File: ‘ooxx.txt’
  Size: 17        	Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d	Inode: 34794314    Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2020-11-04 17:13:08.270660356 -0800
Modify: 2020-11-04 17:13:10.095697785 -0800
Change: 2020-11-04 17:15:02.104995105 -0800
```
软链接像Windows的快捷方式。但是无论修改任意一方，都会影响另一方。只不过这时候如果删除被指向的文件，则快捷方式那里就会爆红字体，软链接指向
丢失。


`dd if=/dev/zero of=mydisk.img bs=1048576 count=100` （dd if=/dev/sda3 of=~/xxx.img 就是把整个分区做成了一个压缩文件的备份；
dd if=/dev/sda3 of=/dev/sdb1 就是两个分区对拷）
dd可以拷贝数据生成文件生成块设备等，参数第一个是inputfile if. /dev/zero 是无限大的空，但是不占用太大的磁盘空间. of是输出的文件。
bs=1048576说的是块大小是1M。count=100是说由100 个块，文件总大小一共100M，被0填充的文件。现在我们想拿它作为一个磁盘挂载到文件系统上去。
`losetup /dev/loop0 mydisk.img` 环回接口的挂载. `mke2fs /dev/loop0` 格式化成ext2的文件系统，类似于格式化U盘或者磁盘分区。再把这个
/dev/loop0 挂载到某个目录：/mnt/ooxx, 然后再往里面放一些正常目录里面有的文件和程序，那基本就有docker的意思了：
```
[root@localhost ~]# mkdir lisz
[root@localhost ~]# cd lisz
[root@localhost lisz]# dd if=/dev/zero of=mydisk.img bs=1048576 count=100
100+0 records in
100+0 records out
104857600 bytes (105 MB) copied, 1.51808 s, 69.1 MB/s
[root@localhost lisz]# ll
total 102400
-rw-r--r--. 1 root root 104857600 Nov  4 17:40 mydisk.img
[root@localhost lisz]# losetup /dev/loop0 mydisk.img 
[root@localhost lisz]# ll
total 102400
-rw-r--r--. 1 root root 104857600 Nov  4 17:40 mydisk.img
[root@localhost lisz]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda3        18G  4.3G   14G  25% /
devtmpfs        560M     0  560M   0% /dev
tmpfs           575M     0  575M   0% /dev/shm
tmpfs           575M  8.1M  567M   2% /run
tmpfs           575M     0  575M   0% /sys/fs/cgroup
tmpfs           115M     0  115M   0% /run/user/0
/dev/sda1       297M  152M  146M  51% /boot
[root@localhost lisz]# mke2fs /dev/loop0
mke2fs 1.42.9 (28-Dec-2013)
Discarding device blocks: done                            
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
25688 inodes, 102400 blocks
5120 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67371008
13 block groups
8192 blocks per group, 8192 fragments per group
1976 inodes per group
Superblock backups stored on blocks: 
	8193, 24577, 40961, 57345, 73729

Allocating group tables: done                            
Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done 

[root@localhost lisz]# cd /mnt
[root@localhost mnt]# mkdir ooxx
[root@localhost mnt]# mount /dev/loop0 ./ooxx
[root@localhost mnt]# cd ./ooxx/
[root@localhost ooxx]# ll
total 12
drwx------. 2 root root 12288 Nov  4 17:56 lost+found
[root@localhost ooxx]# cd -
/mnt
[root@localhost mnt]# umount ./ooxx/
[root@localhost mnt]# mount -t ext2 /dev/loop0 /mnt/ooxx
[root@localhost mnt]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda3        18G  4.2G   14G  24% /
devtmpfs        560M     0  560M   0% /dev
tmpfs           575M     0  575M   0% /dev/shm
tmpfs           575M  8.1M  567M   2% /run
tmpfs           575M     0  575M   0% /sys/fs/cgroup
tmpfs           115M     0  115M   0% /run/user/0
/dev/sda1       297M  152M  146M  51% /boot
/dev/loop0       97M  1.6M   91M   2% /mnt/ooxx
[root@localhost mnt]# cd ooxx/
[root@localhost ooxx]# ll
total 12
drwx------. 2 root root 12288 Nov  4 17:56 lost+found
[root@localhost ooxx]# whereis bash
bash: /usr/bin/bash /usr/share/man/man1/bash.1.gz
[root@localhost ooxx]# which bash
/usr/bin/bash
[root@localhost ooxx]# mkdir bin
[root@localhost ooxx]# cp /usr/bin/ba
baobab      base64      basename    bash        bashbug     bashbug-64  batch       
[root@localhost ooxx]# cp /usr/bin/ba
baobab      base64      basename    bash        bashbug     bashbug-64  batch       
[root@localhost ooxx]# cp /usr/bin/bash bin
[root@localhost ooxx]# cd bin
[root@localhost bin]# ll
total 944
-rwxr-xr-x. 1 root root 960392 Nov  4 19:40 bash
[root@localhost bin]# ldd bash
	linux-vdso.so.1 =>  (0x00007fff8c1ac000)
	libtinfo.so.5 => /lib64/libtinfo.so.5 (0x00007f3913bfd000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007f39139f9000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f3913637000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f3913e3b000)
[root@localhost bin]# cd ..
[root@localhost ooxx]# mkdir lib64
[root@localhost ooxx]# cp /lib64/{libtinfo.so.5,libdl.so.2,libc.so.6} ./lib64
[root@localhost ooxx]# cd -
/mnt/ooxx/bin
[root@localhost bin]# cd ../lib64
[root@localhost lib64]# ll
total 2273
-rwxr-xr-x. 1 root root 2116736 Nov  4 19:44 libc.so.6
-rwxr-xr-x. 1 root root   19344 Nov  4 19:44 libdl.so.2
-rwxr-xr-x. 1 root root  174520 Nov  4 19:44 libtinfo.so.5
[root@localhost lib64]# cd -
/mnt/ooxx/bin
[root@localhost bin]# cd ..
[root@localhost ooxx]# cp /lib64/ld-linux-x86-64.so.2 ./lib64/
[root@localhost ooxx]# cd lib64/
[root@localhost lib64]# ll
total 2427
-rwxr-xr-x. 1 root root  155064 Nov  4 19:47 ld-linux-x86-64.so.2
-rwxr-xr-x. 1 root root 2116736 Nov  4 19:44 libc.so.6
-rwxr-xr-x. 1 root root   19344 Nov  4 19:44 libdl.so.2
-rwxr-xr-x. 1 root root  174520 Nov  4 19:44 libtinfo.so.5
[root@localhost lib64]# cd ooxx
-bash: cd: ooxx: No such file or directory
[root@localhost lib64]# cd ..
[root@localhost ooxx]# ll
total 16
drwxr-xr-x. 2 root root  1024 Nov  4 19:40 bin
drwxr-xr-x. 2 root root  1024 Nov  4 19:47 lib64
drwx------. 2 root root 12288 Nov  4 17:56 lost+found
[root@localhost ooxx]# chroot ./
bash-4.2# ll
bash: ll: command not found
bash-4.2# ls
bash: ls: command not found
bash-4.2# echo $
$
bash-4.2# echo $$
37455
bash-4.2# vi
bash: vi: command not found
bash-4.2# cat
bash: cat: command not found
bash-4.2# echo "Hello lisz" > /abc.txt
bash-4.2# pwd
/
bash-4.2# exit
exit
[root@localhost ooxx]# ll
total 18
-rw-r--r--. 1 root root    11 Nov  4 19:49 abc.txt
drwxr-xr-x. 2 root root  1024 Nov  4 19:40 bin
drwxr-xr-x. 2 root root  1024 Nov  4 19:47 lib64
drwx------. 2 root root 12288 Nov  4 17:56 lost+found
[root@localhost ooxx]# echo $$
2329
[root@localhost ooxx]# cd
[root@localhost ~]# umount /mnt/ooxx
[root@localhost ~]# cd /mnt/ooxx
[root@localhost ooxx]# ll
total 0
```
上面中的mydisk.img就相当于是个docker的镜像文件。Docker是个image里面要先放我们的程序，docker是个容器，是个虚幻的东西，是个命名空间，
里面跑的是进程，没有OS的内核，所有的Docker复用物理机统一的内核。先有镜像，才有container容器这个概念，镜像在磁盘上就是image，需要先挂载，
挂载之后，切换到根目录，然后读取里面进程的执行文件，再准备命名空间，然后再把它跑在这个命名空间里面，程序就跑起来了，这些都源于VFS的支撑。

### socket
`lsof` 命令可以显示进程打开了哪些文件，比如 `lsof -p $$` $$表示当前的这个bash进程:
```
[root@localhost ~]# lsof -p $$
COMMAND   PID USER   FD   TYPE DEVICE  SIZE/OFF     NODE NAME
bash    38028 root  cwd    DIR    8,3      4096 33574977 /root
bash    38028 root  rtd    DIR    8,3       224       64 /
bash    38028 root  txt    REG    8,3    960392 50394702 /usr/bin/bash
bash    38028 root  mem    REG    8,3     61752   117379 /usr/lib64/libnss_files-2.17.so
bash    38028 root  mem    REG    8,3 106070960 17091920 /usr/lib/locale/locale-archive
bash    38028 root  mem    REG    8,3   2116736    93297 /usr/lib64/libc-2.17.so
bash    38028 root  mem    REG    8,3     19344    93303 /usr/lib64/libdl-2.17.so
bash    38028 root  mem    REG    8,3    174520   133671 /usr/lib64/libtinfo.so.5.9
bash    38028 root  mem    REG    8,3    155064    93290 /usr/lib64/ld-2.17.so
bash    38028 root  mem    REG    8,3     26254 33950457 /usr/lib64/gconv/gconv-modules.cache
bash    38028 root    0u   CHR  136,1       0t0        4 /dev/pts/1
bash    38028 root    1u   CHR  136,1       0t0        4 /dev/pts/1
bash    38028 root    2u   CHR  136,1       0t0        4 /dev/pts/1
bash    38028 root  255u   CHR  136,1       0t0        4 /dev/pts/1
```
第一行表示当前目录；倒数第4行0u表示标准输入；倒数第3行1u表示标准输出；倒数第2行1u表示报错输出。u表示读写都可以。/dev/pts/1表示标准输出连到
了虚拟终端，就是这个打开的command页面任何程序都有0、1、2三个文件描述符。什么是文件描述符？他代表打开的文件，它里面会有：类型、设备号、偏移量、
文件在哪儿、inode号：
```
[root@localhost ~]# vim ooxx.txt
[root@localhost ~]# exec 8< ooxx.txt
[root@localhost ~]# cd /proc/$$/fd
[root@localhost fd]# ll
total 0
lrwx------. 1 root root 64 Nov  4 20:56 0 -> /dev/pts/1
lrwx------. 1 root root 64 Nov  4 20:56 1 -> /dev/pts/1
lrwx------. 1 root root 64 Nov  4 20:56 2 -> /dev/pts/1
lrwx------. 1 root root 64 Nov  4 20:57 255 -> /dev/pts/1
lr-x------. 1 root root 64 Nov  4 21:32 8 -> /root/ooxx.txt
[root@localhost fd]# lsof -p $$
COMMAND   PID USER   FD   TYPE DEVICE  SIZE/OFF     NODE NAME
bash    38028 root  cwd    DIR    0,3         0    91042 /proc/38028/fd
bash    38028 root  rtd    DIR    8,3       224       64 /
bash    38028 root  txt    REG    8,3    960392 50394702 /usr/bin/bash
bash    38028 root  mem    REG    8,3     61752   117379 /usr/lib64/libnss_files-2.17.so
bash    38028 root  mem    REG    8,3 106070960 17091920 /usr/lib/locale/locale-archive
bash    38028 root  mem    REG    8,3   2116736    93297 /usr/lib64/libc-2.17.so
bash    38028 root  mem    REG    8,3     19344    93303 /usr/lib64/libdl-2.17.so
bash    38028 root  mem    REG    8,3    174520   133671 /usr/lib64/libtinfo.so.5.9
bash    38028 root  mem    REG    8,3    155064    93290 /usr/lib64/ld-2.17.so
bash    38028 root  mem    REG    8,3     26254 33950457 /usr/lib64/gconv/gconv-modules.cache
bash    38028 root    0u   CHR  136,1       0t0        4 /dev/pts/1
bash    38028 root    1u   CHR  136,1       0t0        4 /dev/pts/1
bash    38028 root    2u   CHR  136,1       0t0        4 /dev/pts/1
bash    38028 root    8r   REG    8,3        64 34794316 /root/ooxx.txt
bash    38028 root  255u   CHR  136,1       0t0        4 /dev/pts/1
```
现在多了个8号文件描述符，且是个读取的FD，类型是个普通文件REG，后面的3表示第3分区，然后是偏移量，这是用命令`lsof -op $$`:
```
[root@localhost fd]# lsof -op $$
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    38028 root  cwd    DIR    0,3           91042 /proc/38028/fd
bash    38028 root  rtd    DIR    8,3              64 /
bash    38028 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    38028 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    38028 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    38028 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    38028 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    38028 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    38028 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    38028 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    38028 root    0u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    1u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    2u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    8r   REG    8,3    0t0 34794316 /root/ooxx.txt
bash    38028 root  255u   CHR  136,1    0t0        4 /dev/pts/1
```
8号文件描述符刚刚被打开，所以偏移量还是0，一读的话读第一个字节，inode号就是`34794316`.
往外读数据并放到变量a中，标准输入流，& 8表示来自8号文件描述符。但是read有一个特征就是读到换行符就不读了，所以他不会把整个文件都读完，而是
只读一行，所以偏移量就是一行的偏移量:
```
[root@localhost fd]# read a 0<& 8
[root@localhost fd]# echo $a
aaewhifdiewufhiwuefhwef
[root@localhost fd]# lsof -op $$
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    38028 root  cwd    DIR    0,3           91042 /proc/38028/fd
bash    38028 root  rtd    DIR    8,3              64 /
bash    38028 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    38028 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    38028 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    38028 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    38028 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    38028 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    38028 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    38028 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    38028 root    0u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    1u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    2u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    8r   REG    8,3   0t24 34794316 /root/ooxx.txt
bash    38028 root  255u   CHR  136,1    0t0        4 /dev/pts/1
```
在开另一个窗口或者标签页中ssh到同一主机，在/proc/$$/fd下面执行 exec 6< ~/ooxx.txt
```
[root@localhost fd]# exec 6< ~/ooxx.txt 
[root@localhost fd]# ll
total 0
lrwx------. 1 root root 64 Nov  4 21:59 0 -> /dev/pts/2
lrwx------. 1 root root 64 Nov  4 21:59 1 -> /dev/pts/2
lrwx------. 1 root root 64 Nov  4 21:59 2 -> /dev/pts/2
lrwx------. 1 root root 64 Nov  4 22:05 255 -> /dev/pts/2
lr-x------. 1 root root 64 Nov  4 21:59 6 -> /root/ooxx.txt
[root@localhost fd]# lsof -op $$
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    38652 root  cwd    DIR    0,3           97440 /proc/38652/fd
bash    38652 root  rtd    DIR    8,3              64 /
bash    38652 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    38652 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    38652 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    38652 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    38652 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    38652 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    38652 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    38652 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    38652 root    0u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    1u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    2u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    6r   REG    8,3    0t0 34794316 /root/ooxx.txt
bash    38652 root  255u   CHR  136,2    0t0        5 /dev/pts/2
```
这里可以看到，这个的偏移量位0，多个bash程序打开同一个文件，但是每个fd各自维护各自的指针。有点像Java中的迭代器. pagecache在这里没有展示
现在开始读几行文件：
```
[root@localhost fd]# read a 0<& 6
[root@localhost fd]# echo $a
aaewhifdiewufhiwuefhwef
[root@localhost fd]# read a 0<& 6
[root@localhost fd]# echo $a
dsfsfdsgdsg
[root@localhost fd]# lsof -op $$
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    38652 root  cwd    DIR    0,3           97440 /proc/38652/fd
bash    38652 root  rtd    DIR    8,3              64 /
bash    38652 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    38652 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    38652 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    38652 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    38652 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    38652 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    38652 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    38652 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    38652 root    0u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    1u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    2u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    6r   REG    8,3   0t36 34794316 /root/ooxx.txt
bash    38652 root  255u   CHR  136,2    0t0        5 /dev/pts/2
```

现在回到同一个bash进程，打开第二次同一个文件：
```
[root@localhost fd]# exec 6< ~/ooxx.txt 
[root@localhost fd]# lsof -op $$
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    38028 root  cwd    DIR    0,3           91042 /proc/38028/fd
bash    38028 root  rtd    DIR    8,3              64 /
bash    38028 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    38028 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    38028 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    38028 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    38028 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    38028 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    38028 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    38028 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    38028 root    0u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    1u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    2u   CHR  136,1    0t0        4 /dev/pts/1
bash    38028 root    6r   REG    8,3    0t0 34794316 /root/ooxx.txt
bash    38028 root    8r   REG    8,3   0t24 34794316 /root/ooxx.txt
bash    38028 root  255u   CHR  136,1    0t0        4 /dev/pts/1
```
制造脏页：
```
[root@localhost fd]# cat /proc/vmstat | grep dirty
nr_dirty 0
nr_dirty_threshold 57982
nr_dirty_background_threshold 19327
[root@localhost fd]# exec 9> output.txt
-bash: output.txt: No such file or directory
[root@localhost fd]# cd ~
[root@localhost ~]# exec 9> output.txt
[root@localhost ~]# ll /proc/$$/fd
total 0
lrwx------. 1 root root 64 Nov  4 21:59 0 -> /dev/pts/2
lrwx------. 1 root root 64 Nov  4 21:59 1 -> /dev/pts/2
lrwx------. 1 root root 64 Nov  4 21:59 2 -> /dev/pts/2
lrwx------. 1 root root 64 Nov  4 22:05 255 -> /dev/pts/2
lr-x------. 1 root root 64 Nov  4 21:59 6 -> /root/ooxx.txt
l-wx------. 1 root root 64 Nov  4 23:43 9 -> /root/output.txt
[root@localhost ~]# lsof -op $$
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    38652 root  cwd    DIR    8,3        33574977 /root
bash    38652 root  rtd    DIR    8,3              64 /
bash    38652 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    38652 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    38652 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    38652 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    38652 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    38652 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    38652 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    38652 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    38652 root    0u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    1u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    2u   CHR  136,2    0t0        5 /dev/pts/2
bash    38652 root    6r   REG    8,3   0t36 34794316 /root/ooxx.txt
bash    38652 root    9w   REG    8,3    0t0 33574981 /root/output.txt
bash    38652 root  255u   CHR  136,2    0t0        5 /dev/pts/2
[root@localhost ~]# echo "sdfsadgdsg" >& 9
[root@localhost ~]# cat /procvmstat | grep dirty
cat: /procvmstat: No such file or directory
[root@localhost ~]# cat /proc/vmstat | grep dirty
nr_dirty 1
nr_dirty_threshold 57983
nr_dirty_background_threshold 19327
```
这时候还没刷到磁盘上去，所以还是脏的，过一段时间脏页数就是0了
```
[root@localhost ~]# cat /proc/vmstat | grep dirty
nr_dirty 0
nr_dirty_threshold 57973
nr_dirty_background_threshold 19324
```


### socket演示
在新的Tab中：
```
[root@localhost ~]# echo $$
39769
[root@localhost ~]# cd /proc/$$/fd
[root@localhost fd]# ll
total 0
lrwx------. 1 root root 64 Nov  4 23:51 0 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  4 23:51 1 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  4 23:51 2 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  4 23:51 255 -> /dev/pts/0
[root@localhost fd]# exec 8<> /dev/tcp/www.baidu.com/80
[root@localhost fd]# ll
total 0
lrwx------. 1 root root 64 Nov  4 23:51 0 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  4 23:51 1 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  4 23:51 2 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  4 23:51 255 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  4 23:55 8 -> socket:[109099]
[root@localhost fd]# lsof -op $$
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    39769 root  cwd    DIR    0,3          108696 /proc/39769/fd
bash    39769 root  rtd    DIR    8,3              64 /
bash    39769 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    39769 root  mem    REG    8,3          117389 /usr/lib64/libresolv-2.17.so
bash    39769 root  mem    REG    8,3          117377 /usr/lib64/libnss_dns-2.17.so
bash    39769 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    39769 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    39769 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    39769 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    39769 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    39769 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    39769 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    39769 root    0u   CHR  136,0    0t0        3 /dev/pts/0
bash    39769 root    1u   CHR  136,0    0t0        3 /dev/pts/0
bash    39769 root    2u   CHR  136,0    0t0        3 /dev/pts/0
bash    39769 root    8u  IPv4 109099    0t0      TCP localhost.localdomain:49892->104.193.88.123:http (ESTABLISHED)
bash    39769 root  255u   CHR  136,0    0t0        3 /dev/pts/0
```
`exec 8<> /dev/tcp/www.baidu.com/80` 中，内核中其实有后面这个目录但是我们看不到。最终变成了一个文件描述符8指向了一个socket，type在
`lsof -op $$`查看的时候是IPV4。平时看不到这个socket，只有他产生的时候这个文件描述符才能标志出他来，通过TCP协议从自己的一个随机端口号，
连接到了百度的80端口


### 管道 Pipeline
死记硬背过：任何程序都有0、1、2，标准输入输出和报错。程序还可以打开其他的文件，描述符位4、5、6... 我们还可以看到他：
```
cd /proc/$$/fd
```
虚拟文件系统，他的每个目录并不一定都在磁盘上，像是proc，是内核映射目录，映射的是内核中的一些变量属性等，只有开机之后/proc才有内容，
下面的每个数字就是pid，这又一次说明了"一切皆文件"。$$
是当前bash的pid，$BASHPID也能取到，但是$$比较特殊，后面讲管道的时候说。`prod/$$/fd`下面是当前bash的文件描述符，`lsof -op $$`查看各个
fd的详细信息。OS基于以上的本质之上，Linux有重定向的机制（重定向不是命令）。打开文件的时候，如果这样写：
```
File file = new File("/ooxx.txt");
out（fd） = new outputstream(file);
out.write("abc");
```
在程序员看来，一定向这个文件去写，写死了。而在OS看来，输出写的时候互伴随着得到一个fd，而且能看到，在java里面的那个out对象，只不过fd指向了
ooxx.txt，映射关系会在OS的`/proc/$$/fd`这里被暴露出来, 然后，有一个机制，叫做"重定向"，别人可以选择让java那个IO指向别的地方。重定向如何
实现的？我们流的方向无非就是输入和输出，I/O。输入就是<, 输出就是>，这是输入输出重定向操作符的基本符。如何实现？启动ls，任何程序，包括这个ls，
也有0、1、2，其中1标准输出是打印到了屏幕上，如果把输出的结果指向~/ls.out 屏幕就看不到了. `ls 1> ~/ls.out` >就是说标准输出不要再指向屏幕了，
换一个映射，换到某个文件上去。所以就会看到ls.out这个文件。cat有两个流输入流把文件内容读入到程序，输出流把内容打印到屏幕. 还有read命令，
对换行符极其敏感，读到换行符就退出自己：
```
[root@localhost ~]# read a
akhfkjsaf
[root@localhost ~]# echo $a
akhfkjsaf
```
把键盘的标准输入读到，然后看最后这个输入字符是不是回车，如果是，则完成赋值，所以打印变量a则可以输出刚才输入的值。 重定向read的输入流，但是
read对换行符敏感，所以只有第一行的内容被赋值
```
[root@localhost ~]# read a 0<ooxx.txt
[root@localhost ~]# echo $a
aaewhifdiewufhiwuefhwef
```
重定向符号，无论是>还是<它的左边都必须是程序的文件描述符0、1、2，且他跟重定向符号之间不能有空白符，在命令行中，空白符极其敏感会做字符串切割，
切开之后会认为0、1、2是参数，而不是文件描述符了。右边是可以有空白符的。有时候可以把两个重定向符号对接起来:
```
[root@localhost ~]# ls ./ /ooxx
ls: cannot access /ooxx: No such file or directory
./:
anaconda-ks.cfg  Desktop    Downloads             lisz   ooxx.txt         output.txt  Public    Templates
cat.out          Documents  initial-setup-ks.cfg  Music  original-ks.cfg  Pictures    read.out  Videos
```
ls命令的输出，一个走了1（标准输出）一个走了2（报错输出），重定向标准输出，就只剩下报错信息了。
```
[root@localhost ~]# ls ./ /ooxx 1> ls01.out
ls: cannot access /ooxx: No such file or directory
[root@localhost ~]# 
```
两个也可以都写到同一个文件里，但是会覆盖，有个办法可以不让他们覆盖而且不用>>符号，就是把2接到1上，再把1接到文件上，但是<>的右边如果是文件描
述符，则需要在他们之间加"&",这是个硬性语法约束：
```
[root@localhost ~]# ls ./ /ooxx 2>&1 1>ls04.out
ls: cannot access /ooxx: No such file or directory
[root@localhost ~]# cat ls04
cat: ls04: No such file or directory
```
发现还是不对，2先指向了1的目标，1又被修改了，指向了文件，所以这是有顺序的，他俩应该翻个个：
```
[root@localhost ~]# ls ./ /ooxx 1>ls04.out 2>&1
[root@localhost ~]# cat ls04.out 
ls: cannot access /ooxx: No such file or directory
./:
anaconda-ks.cfg
cat.out
Desktop
Documents
Downloads
initial-setup-ks.cfg
lisz
ls01.out
ls04.out
Music
ooxx.txt
original-ks.cfg
output.txt
Pictures
Public
read.out
Templates
Videos
```

### 管道：|
什么是管道？先准备一个test.txt文件
head -2 test.txt 和 tail -5 test.txt可以显示前两行和后5行，那只想显示第8行怎么办？用管道：
```
head -8 test.txt | tail -1
```
管道是把前面的输出作为后面的输入

### 父子进程
```
[root@localhost ~]# echo $$
50243
[root@localhost ~]# /bin/bash
[root@localhost ~]# echo $$
51505
[root@localhost ~]# pstree
systemd─┬─ModemManager───2*[{ModemManager}]
        ├─NetworkManager───2*[{NetworkManager}]
        ├─abrt-dbus───2*[{abrt-dbus}]
        ├─2*[abrt-watch-log]
        ├─abrtd
        ├─alsactl
        ├─atd
        ├─auditd─┬─audispd─┬─sedispatch
        │        │         └─{audispd}
        │        └─{auditd}
        ├─avahi-daemon───avahi-daemon
        ├─bluetoothd
        ├─chronyd
        ├─crond
        ├─cupsd
        ├─dbus-daemon───{dbus-daemon}
        ├─dnsmasq───dnsmasq
        ├─gssproxy───5*[{gssproxy}]
        ├─ksmtuned───sleep
        ├─libvirtd───15*[{libvirtd}]
        ├─login───bash
        ├─lsmd
        ├─lvmetad
        ├─master─┬─pickup
        │        └─qmgr
        ├─packagekitd───2*[{packagekitd}]
        ├─polkitd───5*[{polkitd}]
        ├─rngd
        ├─rsyslogd───2*[{rsyslogd}]
        ├─smartd
        ├─sshd───sshd───bash───bash───pstree
... ... 
```
最后这一行可以看到bash的两个父子进程
```
[root@localhost ~]# ps -ef | grep 50243
root      50243  50240  0 17:32 pts/0    00:00:00 -bash
root      51505  50243  0 19:45 pts/0    00:00:00 /bin/bash
root      51629  51505  0 19:56 pts/0    00:00:00 grep --color=auto 50243
[root@localhost ~]# exit
exit
[root@localhost ~]# echo $$
50243
```
进程之间，变量和数据隔离：
```
[root@localhost ~]# echo $$
50243
[root@localhost ~]# x=100
[root@localhost ~]# echo $x
100
[root@localhost ~]# /bin/bash
[root@localhost ~]# echo $$
51654
[root@localhost ~]# echo $x

[root@localhost ~]# 
```
子进程中取不到x的值，要想取到，在父进程中export一下变量就可以在子进程中看到了：
```
[root@localhost ~]# exit
exit
[root@localhost ~]# echo $x
100
[root@localhost ~]# export x
[root@localhost ~]# /bin/bash
[root@localhost ~]# echo $x
100
[root@localhost ~]#
```
这就是为什么/etc/profile设置环境变量的时候需要export他们，父进程定义好了，各个子（孙）进程就都知道有这些变量了。

### 指令块
```
[root@localhost ~]# { echo "eadfsa"; echo "123";}
eadfsa
123
```
{}里面的所有指令是在同一个父进程里执行的。这里的{ 后面一定加一个空格
```
[root@localhost ~]# a=1
[root@localhost ~]# echo $a
1
[root@localhost ~]# {a=9;echo "sfhsdkf";} | cat
bash: syntax error near unexpected token `}'
[root@localhost ~]# { a=9; echo "sfhsdkf"; } | cat
sfhsdkf
[root@localhost ~]# echo $a
1
```
管道可以衔接输出和输入，但如果就知道这一点，则工作中容易踩坑，而且死的很惨。管道的机制是：bash会解释文本段，一旦看到里面有管道，则现在左边
启动一个子进程，右边再启动一个子进程，并让两个进程的输入输出对接起来，左边的子进程再去执行a=9等命令，右边的命令再执行cat。子进程中虽然改了
a的值，但是由于进程间变量的隔离，在父进程中a还是那个值。
左边不是该启动一个子进程吗？
```
[root@localhost ~]# echo $$ | cat
51757
[root@localhost ~]# echo $$
51757
```
这是因为有两个方式可以取出进程ID号：
```
[root@localhost ~]# echo $$ | cat
51757
[root@localhost ~]# echo $BASHPID | cat
52042
```
而且$$的优先级高过了管道，而$BASHPID低于管道，换句话说：bash是个解释执行的程序体系，回车之后先做参数扩展把$$展开成具体的ID号。
执行以下命令，生成两个子进程，并且让他打印其中一个子进程的进程号
```
[root@localhost ~]# { echo $BASHPID; read x; } | { cat ; echo $BASHPID ; read y; }
52103
```
然后再重新开启一个命令行，查看进程关系，可以看出父进程51757生出了两个子进程：52103和52104，并且第一个子进程已经被打印了出来

```
[root@localhost ~]# ps -ef | grep 51757
root      51757  50243  0 20:02 pts/0    00:00:00 /bin/bash
root      52103  51757  0 20:37 pts/0    00:00:00 /bin/bash
root      52104  51757  0 20:37 pts/0    00:00:00 /bin/bash
root      52219  52109  0 20:45 pts/1    00:00:00 grep --color=auto 51757
```
再去查看52103的输出，可见他指向了一个pipe：
```
[root@localhost fd]# cd /proc/52103/fd
[root@localhost fd]# ll
total 0
lrwx------. 1 root root 64 Nov  6 20:54 0 -> /dev/pts/0
l-wx------. 1 root root 64 Nov  6 20:54 1 -> pipe:[237998]
lrwx------. 1 root root 64 Nov  6 20:38 2 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  6 20:54 255 -> /dev/pts/0
```
再去查看另一个子进程52104的输入：
```
[root@localhost fd]# cd /proc/52104/fd
[root@localhost fd]# ll
total 0
lr-x------. 1 root root 64 Nov  6 20:57 0 -> pipe:[237998]
lrwx------. 1 root root 64 Nov  6 20:57 1 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  6 20:38 2 -> /dev/pts/0
lrwx------. 1 root root 64 Nov  6 20:57 255 -> /dev/pts/0
```
这个进程的输入接到了同一个管道上。然后查看两个进程的各个文件描述符和管道：
```
[root@localhost fd]# lsof -op 52103
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    52103 root  cwd    DIR    8,3        33574977 /root
bash    52103 root  rtd    DIR    8,3              64 /
bash    52103 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    52103 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    52103 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    52103 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    52103 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    52103 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    52103 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    52103 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    52103 root    0u   CHR  136,0    0t0        3 /dev/pts/0
bash    52103 root    1w  FIFO    0,8    0t0   237998 pipe
bash    52103 root    2u   CHR  136,0    0t0        3 /dev/pts/0
bash    52103 root  255u   CHR  136,0    0t0        3 /dev/pts/0
```
```
[root@localhost fd]# lsof -op 52104
COMMAND   PID USER   FD   TYPE DEVICE OFFSET     NODE NAME
bash    52104 root  cwd    DIR    8,3        33574977 /root
bash    52104 root  rtd    DIR    8,3              64 /
bash    52104 root  txt    REG    8,3        50394702 /usr/bin/bash
bash    52104 root  mem    REG    8,3          117379 /usr/lib64/libnss_files-2.17.so
bash    52104 root  mem    REG    8,3        17091920 /usr/lib/locale/locale-archive
bash    52104 root  mem    REG    8,3           93297 /usr/lib64/libc-2.17.so
bash    52104 root  mem    REG    8,3           93303 /usr/lib64/libdl-2.17.so
bash    52104 root  mem    REG    8,3          133671 /usr/lib64/libtinfo.so.5.9
bash    52104 root  mem    REG    8,3           93290 /usr/lib64/ld-2.17.so
bash    52104 root  mem    REG    8,3        33950457 /usr/lib64/gconv/gconv-modules.cache
bash    52104 root    0r  FIFO    0,8    0t0   237998 pipe
bash    52104 root    1u   CHR  136,0    0t0        3 /dev/pts/0
bash    52104 root    2u   CHR  136,0    0t0        3 /dev/pts/0
bash    52104 root  255u   CHR  136,0    0t0        3 /dev/pts/0
```
同一个管道在两个进程中分别为写出和读入。

### pagecache粗略的理解
pagecache可以没有，OS中的进程如果想读取数据的时候，只是调了内核的方法，内核调用驱动，驱动去找硬件，把数据返回给程序。这样收到IO的延迟会
比较多。pagecache实际上就是加了个缓存。缓存可以在多个地方：应用程序里面可以有个buffer，内核里也有buffer，应用程序通过系统调用来访问内核，
system call是通过 `int 0x80` 中断被调用，int是CPU指令。0x80是128=10000000b 这个值是要放到CPU的寄存器里的，和中断向量表去做匹配，这个
表里面会有0、1、2...128、... 255号（一个字节），128这里有一个callback （方法）在用户程序里面，中断向量表里面key就是0-255这个数字，
callback就是其中128对应的这个value。想调用某个系统调用的时候，其实是完成了一个
int 0x80，而在其他的寄存器里面放了系统调用的参数，int 0x80 一旦被CPU读到之后，就开始到128的callback，开始保存现场，从用户态切换到内核态，
因为这个callback在内核里。CPU既要读程序，也会读内核里的指令去执行，这就有个切换了。内核的指令从哪里开始执行呢？就靠这个callback这个地址来
调用，这里面有个保护现场和切换用户态和内核态的过程。举个例子：在调用read(fd8)读取的时候，即便是想制度一个字节，也会读取一个pagecache=4k
回来，这里就是一个内核缓冲区。内核缓冲区基本上就是压榨内存，所以这种pagecache会很多，不主动释放，读的东西越多，缓存的也越多。调用的虽然是
read，但是读的时候其实还有细活：首先硬盘上也有缓冲区。读取的时候还有一个协处理器：DMA，使得数据不用通过CPU寄存器。如果没有DMA，则需要寄存器
从硬盘转到pagecache中去。数据是可以经过（不准确）DMA从硬盘拷贝到内存，等于是把CPU这个过程切出来，地址总线可以交叉间隔使用。CPU就被解放出来
了，可以忙点别的。这样比什么事情都停了、CPU一直在搬数据这个过程更高效。所以管DMA叫做协处理器。

有两个应用程序app1和2，app1是running的话，要读硬盘，则调用系统调用，产生80中断。CPU就已经知道要切换到内核态了，用户程序app1这时候被"保护现
场"了，就是曾经L各级缓存里面的数据全都放到内存里，CPU从用户态切换到内核态，然后开始执行内核里相应的系统调用，这时候先看pagecache有没有，
没有的话就触发"缺页中断"，然后走DMA协处理器，协处理器完成数据的获取。最主要的是我们的app1进程会进入挂起的状态，就不再系统内核的调度的范围了，
不活跃，未来也不会调度他了，在接下来的时间片里别的app，比如app2参与被调度，而app1不参与。数据拷完了之后DMA还会给CPU一个中断，会知道app1
关注过这个数据，然后app1的状态被变为可运行，在这之后的某个时间片才能让app1被调度到。这时候再次执行的时候，恢复现场页已经有了，数据拷完了。
app1就可以继续执行了。简而言之：系统调用执行读硬盘的时候，进程会被暂停，数据读到了pagecache之后进程会继续。没有中断的话，CPU就被焊死在
一个进程上，再也不能干别的事情了。
### 实操演示
有两种关机方法：  
方法1：轻轻按关机，然后dirty的pagecache会被落地到硬盘，然后再关机。  
方法2：直接把电源给拔掉了，这样计算机就来不及把内存的脏页刷出去。

这里有一个


把文件
读到pagecache中，内核在一个app看来

VFS树、inode、pagecache在内存里， 4k、dirty、flush  